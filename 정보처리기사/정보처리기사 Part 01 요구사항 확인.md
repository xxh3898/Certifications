# Chapter 01 현행 시스템 분석하기

## Section 01 소프웨어 공학

### 1. HIPO (Hierachy plus Input Process Output)

* 기본 모델로 입력, 처리, 출력으로 구성되는 시스템 분석 및 설계와 시스템 문서화용 기법입니다.
* 일반적으로 가시적 도표(Visual Table of Contents), 총체적 다이어그램(Over-view Diagram), 세부적 다이어그램(Detail Diagram)으로 구성됩니다.
* 구조도(가시적 도표, Visual Table of Contents), 개요, 도표(Index Diagram), 상세 도표(Detail Diagram)로 구성됩니다.
* 가시적 도표는 전체적인 기능과 흐름을 보여주는 구조입니다.
* 기능과 자료의 의존 관계를 동시에 표현할 수 있습니다.
* 보기 쉽고 이해하기 쉬우며 유지보수가 용이합니다.
* 하향식 소프트웨어 개발을 위한 문서화 도구입니다.

### 2. V-모델

* 폭포수 모델[^1]에 시스템 검증과 테스트 작업을 강조한 모델입니다.
* 세부적인 프로세스로 구성되어 있어서 신뢰도 높은 시스템 개발에 효과적입니다.
* 개발 단계의 작업을 확인하기 위해 테스트 작업을 수행합니다.
* 생명 주기 초반부터 테스트 작업을 지원합니다.
* 코드뿐만 아니라 요구사항과 설계 결과도 테스트할 수 있어햐 합니다.
* 폭포수 모델보다 반복과 재처리 과정이 명확합니다.
* 테스트 작업을 단계별로 구분하므로 책임이 명확해집니다.

### 3. 재공학

#### 소프트웨어 재사용(Software Reusability)의 개념

* 이미 개발되어 그 기능 및 성능, 품질을 인정받았던 소프트웨어의 전체 또는 일부분을 다시 사용하여 새롭게 개발하는 기법입니다.
* 1990년대의 클래스, 객체 등의 소프트웨어 요소가 소프트웨어 재사용성을 크게 향상시킵니다.

#### 재사용의 장점

* 개발 시간 및 비용 감소
* 품질 향상
* 생산성 향상
* 신뢰성 향상
* 구축 방법에 대한 지식의 공유
* 프로젝트 실패 위험 감소

#### 소프트웨어 재공학(Software Reengineering)의 개념

* 소프트웨어 위기를 개발의 생산성이 아닌 유지보수의 생산성으로 해결하려는 방법을 의미합니다.
* 기존 시스템을 이용하여 보다 나은 시스템을 구축하고 새로운 기능을 추가하여 소프트웨어 성능을 향상시키는 기법입니다.
* 데이터와 기능들의 개조 및 개선을 통해 유지보수의 용이성을 향상시키고자 합니다.
* 현재의 시스템을 변경하거나 재구조화(Restructuring)하는 것입니다.
* 재구조화는 재공학의 한 유형으로 사용자의 요구사항이나 기술적 설계의 변경 없이 프로그램을 개선하는 것입니다.
* 사용자의 요구사항을 변경시키지 않고, 기술적 설계를 변경하여 프로그램을 개선하는 것도 재공학에 해당됩니다.
* **재공학의 과정**
    * 분석(Analysis)
    * 구성(Restructuring)
    * 역공학(Reverse Engineering)
    * 이식(Migration)

#### 재공학의 목표

* 소프트웨어의 유지보수성 향상이 최우선 목표입니다.
* 복잡한 시스템을 다루는 방법을 구현하기 위해서입니다.
* 다른 뷰의 생성을 위해서입니다.
* 잃어버린 정보의 복구 및 제거를 하기 위해서입니다.
* 재사용이 용이하도록 하기 위해서입니다.
* 소프트웨어의 수명을 연장하기 위해서입니다.

### 5. 역공학

* 소프트웨어를 분석하여 소프트웨어 개발 과정과 데이터 처리 과정을 설명하는 분석 및 설계 정보를 재발견하거나 다시 만들어내는 작업입니다.
* 현재 프로그램으로부터 데이터, 아키텍처, 절차에 관한 분석 및 설계 정보를 추출하는 작업입니다.
* 역공학의 가장 간단하고 오래된 형태는 재문서화라고 할 수 있습니다.
* 기존 소프트웨어의 구성요소와 그 관계를 파악하여 설계도를 추출합니다.

## Section 02 소프웨어 개발 방법론

### 1. 생명주기

#### 소프트웨어 생명주기(Software Life Cycle)

* 소프트웨어 제품의 개념 형성에서 시작하여 운용/유지보수에 이르기까지 변화의 모든 과정입니다.
* **일반적인 소프트웨어 생명주기**
    1.  타당성 검토
    2.  개발 계획
    3.  요구사항 분석
    4.  설계
    5.  구현
    6.  테스트
    7.  운용
    8.  유지보수

#### 소프트웨어 생명주기의 역할

* 프로젝트의 비용 산정과 개발 계획을 수립할 수 있는 기본 골격이 됩니다.
* 용어의 표준화를 가능하게 합니다.
* 문서화가 충실한 프로젝트 관리를 가능하게 합니다.
* **소프트웨어 생명주기의 단계(공정)**
    1.  타당성 검토
    2.  개발 계획
    3.  요구사항 분석
    4.  설계
    5.  구현
    6.  테스트

### 2. 생명주기 모형의 종류

#### 1. 폭포수 모형(Waterfall Model)

* Boehm이 제시한 고전적 생명주기 모형으로, 소프트웨어 개발 과정의 각 단계가 순차적으로 진행되는 모형입니다.
* 선형 순차적 모델이라고도 합니다.
* **폭포수 모형의 개발 단계**
    1.  타당성 검사: 시스템을 개발하는 것이 타당한지를 검사하는 단계입니다.
    2.  계획: 추진 방안을 제시하고 개발 비용, 소요 기간, 인력 등 개발 계획을 수립하는 단계입니다.
    3.  요구분석: 시스템의 기능, 성능, 환경 등의 요구사항을 면밀히 분석하는 단계입니다.
    4.  기본 설계: 하드웨어, 소프트웨어, 제어 구조, 자료 구조 등의 설계를 작성한는 단계입니다.
    5.  상세 설계: 각 단위 프로그램의 제어, 자료 구조와 인터페이스를 상세히 작성하는 단계입니다.
    6.  구현: 설계된 문서를 통해 실제 컴퓨터가 작동할 수 있는 코드로 변환하는 단계입니다.
    7.  시험(검사): 구현한 프로그램을 테스트하여 요구조건에 맞는지 확인하는 단계입니다.
    8.  운용: 실제 시스템에 적용하여 실행되는지 확인하는 단계입니다.
    9.  유지보수: 개발 후 발생하는 문제점이나 수정 사항을 적용하는 단계로 가장 많은 비용이 소요됩니다.
* **폭포수 모형의 장점**
    * 적용 경험과 성공 사례가 많다.
    * 단계별 정의가 분명하고, 전체 구조의 이해가 용이하다.
    * 단계별 산출물이 명확하다.
* **폭포수 모형의 단점**
    * 개발 과정 중에 발생하는 새로운 요구나 경험을 설계에 반영하기 어렵다.
    * 두 개 이상의 과정이 병행 수행되거나 이전 단계로 넘어가는 경우가 없다.
    * 이전 단계의 오류 수정이 어렵다.

#### 2. 프로토타입 모형(Prototype Model)

* 실제 개발될 시스템의 견본(Prototype)을 미리 만들어 최종 결과물을 예측하는 모형입니다.
* 개발이 완료되고 나서 사용을 하면 문제점을 알 수 있는 폭포수 모형의 단점을 보완하기 위한 모형입니다.
* **프로토타입 모형의 개발 단계:**
    * 요구 수집 -> 빠른 설계 -> 프로토타입 구축 -> 고객 평가 -> 프로토타입 조정 -> 구현
* **프로토타입 모형의 장점**
    * 프로토타입은 발주자나 개발자 모두에게 공동의 참조 모델을 제공한다.
    * 프로토타입은 구현 단계의 골격이 될 수 있다.
    * 최종 결과물이 만들어지기 전에 의뢰자가 결과물의 일부 또는 모형을 볼 수 있다.
    * 요구사항이 충실히 반영된다.
* **프로토타입 모형의 단점**
    * 프로토타입과 실제 소프트웨어와의 차이로 인해 사용자의 혼란이 야기될 수 있다.
    * 프로토타입 폐기로 인해 비경제적일 수 있다.

#### 3. 나선형 모형(Spiral Model)

* Boehm이 제시하였으며, 반복적인 작업을 수행하는 점증적 생명주기 모형입니다.
* 점증적 모형, 집중적 모형이라고도 합니다.
* 소프트웨어 개발 중 발생할 수 있는 위험을 관리하고 최소화하는 것이 목적입니다.
* 나선을 따라서 돌아가면서 각 개발 순서를 반복하여 수행하는 점진적 방식으로 누락된 요구사항을 추가할 수 있습니다.
* 유지보수 과정이 필요 없습니다.
* **나선형 모형의 개발 단계:**
    * 목표 설정 -> 위험 분석 -> 개발과 검증 -> 고객 평가/다음 단계 수립
* **나선형 모형의 장점**
    * 위험 분석 단계에서 기술과 관리 위험 요소들을 하나씩 제거해 나감으로써 완성도 높은 소프트웨어 개발이 가능하다.
    * 비용이나 시간이 많이 소요되는 대규모 프로젝트나 큰 시스템 구축 시 유리하다.
* **나선형 모형의 단점**
    * 위험 분석 단계에서 발견하지 못한 위험 요소로 인해 문제가 발생한다.
    * 적용 경험이나 성공 사례가 많지 않다.

### 3. 애자일(Agile) 방법론

#### 애자일 방법의 개념

* '날렵한, 재빠른'이라는 사전적 의미와 같이 소프트웨어 개발 중 설계 반경에 신속히 대응하여 요구사항을 수용할 수 있습니다.
* 절차와 도구보다 개인과 소통을 중요시하고 고객과의 피드백을 중요하게 생각합니다.
* 소프트웨어가 잘 실행되는 것에 가치를 둡니다.
* 소프트웨어 배포 시차를 최소화할 수 있습니다.
* 특정 방법론이 아닌 소프트웨어를 빠르고 낭비 없이 제작하기 위해 고객과의 협업에 초점을 둡니다.
* **특징:** 짧은 릴리즈와 반복, 점증적 설계, 사용자 참여, 문서 최소화, 비공식적인 커뮤니케이션, 변화
* **종류:** 익스트림프로그래밍(eXtremeProgramming), 스크럼(SCRUM), 린(Lean), DSDM, FDD, Crystal

#### Agile 선언문

* 프로세스나 도구보다 개인과의 소통이 더 중요하다.
* 완벽한 문서보다 실행되는 소프트웨어가 더 중요하다.
* 계약 협상보다 고객과의 협업이 더 중요하다.
* 계획을 따르는 것보다 변경에 대한 응답이 더 중요하다.

### 4. XP (eXtremeProgramming)

#### XP(eXtremeProgramming)의 정의

* 1999년 Kent Beck이 제안하였으며, 개발 단계 중 요구사항의 변동이 심한 경우 적합한 방법론입니다.
* 요구에 맞는 양질의 소프트웨어를 신속하게 제공하는 것을 목표로 합니다.
* 요구사항을 모두 정의해 놓고 작업을 진행하는 것이 아니라, 요구사항이 변경되는 것을 적용하는 방식으로 예측성보다는 적응성에 더 높은 가치를 부여한 방법입니다.
* 고객의 참여와 개발 과정의 반복을 극대화하여 생산성을 향상하는 방법입니다.

#### XP의 5가지 핵심가치

* **소통(Communication):** 개발자, 관리자, 고객 간의 원활한 소통을 지향한다.
* **단순성(Simplicity):** 부가적 기능 또는 미사용 구조와 알고리즘은 배제한다.
* **피드백(Feedback):** 소프트웨어 개발에서 변화는 불가피하다. 이러한 변화는 지속적인 테스트와 통합, 반복적 결함 수정 등을 빠르게 피드백한다.
* **용기(Courage):** 고객 요구사항 변화에 능동적으로 대응한다.
* **존중(Respect):** 개발 팀원 간의 상호 존중을 기본으로 한다.

##### XP 프로세스

| 항목 | 설명 |
| :--- | :--- |
| User Story[^2] | - 일종의 요구사항이다.<br>- UML의 유스 케이스와 같은 목적으로 생성되나 형식이 없고 고객에 의해 작성된다는 것이 다르다. |
| Release Planning | - 몇 개의 스토리가 적용되어 부분적으로 기능이 완료된 제품을 제공하는 것이다.<br>- 부분/전체 개발 완료 시점에 대한 일정을 수립한다. |
| Iteration | - 하나의 릴리즈를 세분화한 단위이며 1~3주 단위로 진행된다.<br>- 반복(Iteration) 진행 중 새로운 스토리가 추가될 경우 진행 중 반복이나 다음 반복에 추가될 수 있다. |
| Acceptance Test | - 릴리즈 단위의 개발이 구현되었을 때 진행하는 테스트이다.<br>- 사용자 스토리에 작성된 요구사항을 확인하여 고객이 직접 테스트한다.<br>- 오류가 발견되면 다음 반복에 추가한다.<br>- 테스트 후 고객의 요구사항이 변경되거나 추가되면 중요도에 따라 우선순위가 변경될 수 있다.<br>- 완료 후 다음 반복을 진행한다. |
| Small Release | - 릴리즈 단위를 기능별로 세분화하면 고객의 반응을 기능별로 확인할 수 있다.<br>- 최종 완제품일 때 고객에 의한 최종 테스트 진행 후 고객에 제공한다. |

##### XP의 12가지 실천사항(Practice)
<table>
    <tr>
        <td>구분</td>
        <td>실천사항</td>
        <td>내용</td>
    </tr>
    <tr>
        <td rowspan="4">Fine scale feedback</td>
        <td>Pair Programming</td>
        <td>하나의 컴퓨터에 2명의 프로그래머가 모든 코드에 대해서 코딩과 리뷰 역학을 바꿔가며 공동작업을 진행한다.</td>
    </tr>
    <tr>
        <td>Plannig Game</td>
        <td>게임처럼 선수와 규칙, 목표를 두고 기획에 임한다.</td>
    </tr>
    <tr>
        <td>Test Driven Development</td>
        <td>실제코드를 작성하기 전에 단위 테스트부터 작성 및 수행하며, 이를 기반으로 코드를 작성한다.</td>
    </tr>
    <tr>
        <td>Whole Team</td>
        <td>개발 효율을 위해 고객을 프로젝트 팀원으로 상주시킨다.</td>
    </tr>
    <tr>
        <td rowspan="3">Continuous process</td>
        <td>Continuous Integration</td>
        <td>상시 빌드 및 배포를 할 수 있는 상태로 유지한다.</td>
    </tr>
    <tr>
        <td>Design Improvement</td>
        <td>기능 변경 없이 중복성/복잡성 제거, 커뮤니케이션 향상, 단순화, 유연성 등을 위한 재구성을 수행한다.</td>
    </tr>
    <tr>
        <td>Small Releases</td>
        <td>짧은 주기로 잦은 릴리즈를 함으로써 고객이 변경사항을 볼 수 있게 한다.</td>
    </tr>
    <tr>
        <td rowspan="4">Shared understanding</td>
        <td>Coding Standards</td>
        <td>소스코드 작성 포맷과 규칙들을 표준화된 관례에 따라 작성한다.</td>
    </tr>
    <tr>
        <td>Collective Code Ownership</td>
        <td>시스템에 있는 소스코드는 팀의 모든 프로그래머가 언제라도 수정할 수 있다.</td>
    </tr>
    <tr>
        <td>Simple Design</td>
        <td>가능한 가장 간결한 디자인 상태를 유지한다.</td>
    </tr>
    <tr>
        <td>System Metaphor</td>
        <td>최종적으로 개발되어야 할 시스템의 구조를 기술한다.</td>
    </tr>
    <tr>
        <td>Programmer welfare</td>
        <td>Sustainable Pace</td>
        <td>일주일에 40시간 이상 작업 금지, 2주 연속 오버타임을 금지한다.</td>
    </tr>
</table>


> [!NOTE] 짝 프로그래밍(Pair Programming)
>
> * 두 사람이 짝이 되어 한 사람은 코딩을, 다른 사람은 검사를 수행하는 방식이다.
> * 코드에 대한 책임을 공유하고, 비형식적인 검토를 수행할 수 있다.
> * 코드 개선을 위한 리팩토링을 장려하며, 생산성이 떨어지지 않는다.

### 5. SCRUM

#### SCRUM의 개념

* 반복적이고 점진적인 소규모 팀 중심의 소프트웨어 개발 방법론입니다.
* 팀원 간 활발한 소통과 협동심이 필요합니다.
* 요구사항 변경에 신속하게 대처할 수 있습니다.
* 신속하게 반복적으로 실제 작동하는 소프트웨어를 제공합니다.
* 개발자들의 팀 구성과 각 구성원의 역할, 일정 결과물 및 그 외 규칙을 정합니다.
* 팀원 스스로 팀을 구성해야 합니다(Self Organizing).
* 개발 작업에 관한 모든 것을 팀원 스스로 해결해야 합니다(Cross Functional).

#### SCRUM의 특징

* 기능 개선점에 우선순위를 부여하고, 개발 주기 동안 실제 동작 가능한 결과를 제공합니다.
* 개발 주기마다 적용된 기능이나 개선점의 리스트를 제공합니다.
* 커뮤니케이션을 위하여 팀은 개방된 공간에서 개발하고, 매일 15분 정도 회의를 합니다.

#### SCRUM의 기본 원리

* 기능 협업을 기준으로 배치된 팀은 스프린트 단위로 소프트웨어를 개발합니다.
* 스프린트는 고정된 30일의 반복이며, 스프린트 시 행하는 작업은 고정됩니다.
* 요구사항, 아키텍처, 설계가 프로젝트 전반에 걸쳐 잘 드러나야 합니다.
* 정해진 시간을 철저히 지켜야 합니다.
* 완료된 모든 작업은 제품 백로그에 기록됩니다.
* 가장 기본적인 정보 교환 수단은 일일 스탠드업 미띵 또는 일일 스크럼입니다.

#### SCRUM 팀의 역할

| 역할 | 설명 |
| :--- | :--- |
| **제품 책임자**<br>(Product Owner) | - 개발 목표에 이해도가 높은 개발의뢰자. 사용자가 담당한다.<br>- 제품 요구사항을 파악하여 기능 목록(Product Backlog)을 작성한다.<br>- 제품 테스트 수행 및 요구사항 우선순위를 갱신한다<br>- 업무 관점에서 우선순위와 중요도를 표시하고 신규 항목을 추가한다.<br>- 스프린트 계획 수립까지만 임무를 수행한다.<br>- 스프린트가 시작되면 팀 운영에 관여하지 않는다. |
| **스크럼 마스터**<br>(SCRUM Master) | - 업무를 배분만 하고 일 강요하지 않는다.<br>- 팀을 스스로 조직하고 관리하도록 지원한다.<br>- 개발 과정에서 스크럼의 원칙과 가치를 지키도록 지원한다.<br>- 개발 과정의 장애 요소를 찾아 제거한다. |
| **스크럼 팀**<br>(SCRUM Team) | - 제품 책임자, 스크럼 마스터를 제외한 팀원을 지칭한다.<br>- 팀원은 5~9명 내외로 구성한다.<br>- 개발자, 디자이너, 제품 검사자 등 모든 팀원이 여기에 해당한다.<br>- 요구사항을 사용자 스토리로 도출하고 구현한다.<br>- 기능을 작업 단위로 나눈다.<br>- 일정, 속도를 추정한 뒤 제품 책임자에게 전달한다.<br>- 스프린트 결과물을 제품 책임자에게 시연한다.<br>- 매일 스크럼 회의에 참여하여 진행 상황을 점검한다. |

##### 1. Product Backlog

* 제품 개발에 필요한 모든 요구사항(User Story)을 우선순위에 따라 나열한 목록입니다.
* 개발 과정에서 새롭게 도출되는 요구사항으로 인해 지속해서 업데이트 됩니다.
* 제품 백로그에 작성된 사용자 스토리를 기반으로 전체 일정 계획인 릴리즈 계획을 수립합니다.

##### 2. Sprint

* 사전적으로 '전력 질주'라는 의미입니다.
* 작은 단위의 개발 업무를 단기간에 전력 질주하여 개발합니다.
* 반복주기(2~4주)마다 이해관계자에게 일의 진척도를 보고합니다.

##### 3. Sprint Planning Meeting

* Product Backlog(제품 기능 목록)에서 진행할 항목을 선택합니다.
* 선택한 Sprint에 대한 단기 일정을 수립하고, 요구사항을 개발자들이 나눠 작업할 수 있도록 Task 단위로 나눕니다.
* 개발자별로 Sprint Backlog를 작성하고 결과물에 대한 반복 완료 시 모습을 결정합니다.
* 수행에 필요한 각정 요구사항을 SCRUM Master에게 보고하여 이해관계자로부터 지원을 받습니다.

##### 4. Daily SCRUM Meeting

* 매일 약속된 시간에 짧은 시간 동안(약 15분) 서서 진행 상황만 점검합니다.
* 스프린트 작업 목록을 잘 개발하고 있는지 확인합니다.
* 한 사람씩 어제 한 일과 오늘 할 일은 이야기합니다.
* 완료된 세부 작업 항목을 완료 상태로 옮겨 스프린트 현황판에 갱신합니다.
* 스크럼 마스터는 방해요소르르 찾아 해결하고 잔여 작업시간을 소멸 차트(Burn down Chart)에 기록합니다.

##### 5. Finished Work

* 모든 스프린트 주기가 완료되면 제품 기능 목록(Product Backlog)의 개발 목표물이 완성됩니다.

##### 6. Sprint Review

* 스프린트 검토 회의(Sprint Review)에 개발자와 사용자가 같이 참석합니다.
* 하나의 스프린트 반복 주기(2~4주)가 끝나면 실행 가능한 제품이 생성되며 이에 대해 검토합니다. 검토는 가능한 4시간 안에 마무리합니다.
* 개선해야 할 사항에 대하여 제품 책임자(Product Owner)는 피드백을 정리하여 제품 기능 목록(Product Backlog)을 작성하여 다음 스프린트에 적용합니다.

##### 7. 스프린트 회고(Sprint Retrospective)

* 그동안 스프린트에서 수행한 활동과 결과물을 살펴봅니다.
* 개선점이 없는지 살펴보고 문제점을 기록하는 정도로 진행합니다.
* 정해진 규칙이나 표준을 잘 수행했는지 확인합니다.
* 팀의 단점을 찾기보다는 강점을 찾아 팀의 능력을 극대화합니다.
* 개발 추정속도와 실제 작업속도를 비교하고 차이가 있다면 이유를 분석합니다.

***

## 각주

[^1]: 소프트웨어 개발 기법으로, 개발 과정이 단계화 되어 있어 관리가 쉬우나 요구분석에 상당한 시간이 소요되며, 일단 분석이 끝나면 수정이 어렵다는 단점을 지닌다.

[^2]: 사용자의 요구사항을 간단한 시나리오로 표현(UML에서의 Use Case와 목적이 같음)